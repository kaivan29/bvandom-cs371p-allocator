PROBLEM STATEMENT/SUMMARY

I was tasked with designing and implementing a memory Allocator class in C++ which mimics the public API of std::allocator. The class has the template < typename T, std::size\_t N>, which indicates that any given Allocator can be instantiated as an allocator of type T with maximum size N bytes, where T and N are specified. The only data structure employed by the Allocator is an array of chars with size N (note that a char is 1 byte). The aspects of the public API that I was responsible for were the default constructor, allocate(), deallocate(), construct(), destroy(), and max\_size(). I was also required to implement a function called view() that is similar to address() from the public API, as well as a private function called valid() to validate my Allocator. Besides implementation, I was required to write test cases for each aspect of my Allocator.

DETAILS

My general concept for memory allocation is based on the one suggested to us by the Professor. Each 'block' is some amount of byte-sized entries in a[.md](.md) (on the stack) which has been allocated for one or more T's or is currently free. A block is associated with the two 'sentinels' that surround it on both sides; each sentinel is sizeof(int) bytes and stores two pieces of information about the block next to it. One is the total size of the block that the sentinel is associated with (e.g. n`*`sizeof(T) if the block was allocated for n T objects), and the other is whether the block is free or not (the total size is positive or negative, respectively). The words 'sentinel' and 'block' take on the above definitions for the Wiki and the rest of my documentation.

Allocation uses a first-fit policy, which means that allocate() traverses a[.md](.md) until a block greater than or equal to the size of requested space is found, after which that block is either split for or allocated in full to the request. If no such block is found, allocate() throws a std::bad\_alloc exception to indicate that it cannot allocate the request. Construction and destruction of T's within a[.md](.md) is the same as provided by the skeleton from Professor Downing, i.e. the copy constructor and destructor are called on T at some pointer in a[.md](.md), which is provided. Deallocation is slightly more complex (note that I do not mean time or space complexity) in that I verify that the provided pointer which is intended for deallocation is actually a valid pointer in a[.md](.md) (mentioned as optional by Professor). This means that providing bad pointers or attempting to deallocate the same pointer twice results in a std::invalid\_argument exception, which is not exactly what std::allocator does in these cases but is a reasonable facsimile. After validating the pointer argument, deallocate() marks the sentinels it located in a[.md](.md) as being free and then coalesces any free blocks which are directly adjacent to the current one.

Valid() uses the sentinels in a[.md](.md), starting at the very first one, to traverse the entire array. In a valid case this traversal will end in the last sentinel, `a[N - sizeof(int)]`. Along the traversal, the value of each left sentinel is used to reach each corresponding right sentinel, and their contents are verified as equal. This invalidates cases where either sentinel does not contain the appropriate size of its associated block, or any two corresponding sentinels do not have equal contents. Finally, the traversal keeps track of which blocks are marked free in order to verify that no two adjacent blocks are both free. This invalidates cases where coalescing was not performed correctly after a deallocation.

I divided my development into testable stages so that writing the Allocator would be faster and I would cause fewer errors for myself.

STAGE 1 - valid(), view()

These two functions form the basis of sanity checking in my Allocator, and so I choose to implement them first. view() was provided to us in class, and I took some time to figure out exactly how it worked (by example - see Piazza @219) before using it myself. Later, I would change the example implementation from Professor Downing to take an integer index instead of a character reference so that I could use view() to write assertions in my unit tests without needing access to a[.md](.md), which is private. For valid(), I identified a number of conditions that would make the sentinels in a[.md](.md) invalid (see above) and then wrote a simple linear traversal of a[.md](.md) by its sentinels to check these conditions against each sentinel.

Later in development, I wrote unit tests for valid() and view() using friend classes `TestValidClass` and `TestViewClass` (respectively) so that I could access the contents of private data member a[.md](.md) directly without making it public. For valid(), I modifed a[.md](.md) to use sentinels validly and invalidly. For view(), I started with a basic single allocation and then wrote two cases that filled a[.md](.md) with the minimum and maximum number of sentinels. For each unit test I verified that view was returning all of the values that I expected it to from a[.md](.md).

STAGE 2 - Constructor, allocate()

In the second stage I implemented the default constructor and allocate(). These two members would be enough to test the first half of Allocator. The constructor simply sets the two sentinels needed to mark all of a[.md](.md) free (where all means all of a[.md](.md) less the two sentinels, of course). It throws an std::invalid\_argument exception if maximum size N is less than the minimum size of a single T and two sentinels.

allocate() first verifies that the requested number n of T's is not negative or greater than all of a[.md](.md) (causes a std::invalid\_argument exception). Then, I proceed with a linear traversal of a[.md](.md) by sentinels, attempting to find a block of size greater than or equal to that of n`*` sizeof(T). If there is an exact match, then I simply mark the corresponding sentinels and return a pointer to the start of the block. If a match is greater than the request size, there are two cases. In the split case, there are enough additional bytes in the block to allow for n`*`sizeof(T) and 2`*`sizeof(int)+sizeof(T), which is the size of a minimum valid block and two sentinels. The split is made such that the first block is n`*`sizeof(T) in size and the remainder goes to the second block. Again an appropriate pointer is returned. In the other case, the block cannot be split into two blocks such that the second has minimum size, so the entire block is given to the request as if it were an exact match - this leads to internal fragmentation, although on average it will be faster than best fit. If there is no match in all of a[.md](.md), the linear traversal completes without any pointer being set, so a std::bad\_alloc is thrown to indicate failure. For both functions I assert that valid() returns true as the last line.

I tested the constructor by using view() to confirm that the sentinels are set to the appropriate value and are in the right locations. I repeated this test to confirm that multiple Allocators are initialized the same way. I tested the exception thrown by the constructor by attempting to construct an Allocator with N less than the minimum allowed. For allocate(), I repurposed the provided test\_one and test\_ten by adding view() checks to confirm the exact results of what I was doing. I also changed test\_ten into a test that fills a[.md](.md) with the most T's possible, checking the result of each allocate() with view(). I tested exceptional cases for allocate as well, in particular by forcing std::bad\_alloc to be thrown.

STAGE 3 - construct(), destroy(), deallocate()

In the third stage I uncommented construct() and destroy() and then implemented deallocate(). First, deallocate() reinterprets the pointer p passed as an argument to an int pointer and decrements it to go backwards to the what should be the left sentinel of the block. Then, it performs a linear traversal of the sentinels of a[.md](.md) using an index into a[.md](.md) until the address of one such sentinel matches the left sentinel's address. If no such match occurs, a std::invalid\_argument is thrown. Then, deallocate() determines the second sentinel using an int pointer by incrementing from p to the end of the block. The resulting address and value are checked against the address and value of the second sentinel determined by indexing, again resulting in either a match or an exception. After verification, the two sentinels are marked as free and coalescing occurs. This is done by checking the sentinels before the left sentinel and after the right sentinel for free blocks; if a free block(s) is found, then a single block is formed from the two (or three) free blocks by marking the outermost left and right sentinels with the sum of the inner block and sentinel sizes.

I tested construct() and destruct() using a dummy class called JustAClass, which increments or decrements a static flag depending on how many times its constructor or destructor has been called. I came up with variations of the basic test for each function. In testing deallocate() I actually tested most of the functions, but I mention the tests here because deallocate was the focus. The most complex part of deallocate was coalescing, so I tested that in `TestAllocator` as well as `MyTestAllocator`; the former tests coalescing by reallocating the freed blocks in a different order, while the latter uses view() to confirm the entries in a[.md](.md). I also wrote a couple of interesting corner cases (pyramid, reverse, etc.) in which allocating a series of different sized blocks, deallocating them in some order, and then reallocating them again could cause complex failures.

Note: I implemented max\_size() at the end of the project because I did not know if it was a requirement. My one test is the only one which doesn't cause valgrind to fail instead of throw an exception, namely to attempt to allocate more than the max size in the first call to allocate().